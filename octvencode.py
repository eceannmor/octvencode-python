import numpy as np

def random_volume_data(resolution: int, threshold: float) -> np.ndarray:
    """
    This function is not a part of the project. It is present only for testing purposes.
    The data generated by this function is not a good demonstration of the project.
    There is actual good data in the samples directory.
    """
    return (np.random.rand(resolution, resolution, resolution)
            < threshold).astype(np.uint8)


def is_volume_slice_homogeneous(vol_slice: np.ndarray) -> bool:
    """
    Checks if the volume slice's values are homogeneous, i.e. if there is a need to split.
    """
    if vol_slice.size < 2:
        return True
    return np.all(vol_slice == vol_slice.flat[0])


def encode_slice_recursive(volume: np.ndarray, x_start: int, x_end: int,
                           y_start: int, y_end: int, z_start: int,
                           z_end: int) -> str:
    """
    Checks if the volume needs to be sliced, if not, returns immediately with the value of the slice
    Else slices the volume and calls itself for all slices
    """

    vol_slice = volume[x_start:x_end, y_start:y_end, z_start:z_end]
    assert vol_slice.size > 0, "What"
    if is_volume_slice_homogeneous(vol_slice):
        # leaf
        return f"l{repr(int(vol_slice.flat[0]))}"

    x_split = [x_start, (x_start + x_end) // 2, x_end]
    y_split = [y_start, (y_start + y_end) // 2, y_end]
    z_split = [z_start, (z_start + z_end) // 2, z_end]

    slices = []

    # order:
    # (0, 0, 0)
    # (1, 0, 0)
    # (0, 1, 0)
    # (1, 1, 0)
    # (0, 0, 1)
    # (1, 0, 1)
    # (0, 1, 1)
    # (1, 1, 1)
    for z in (0, 1):
        for y in (0, 1):
            for x in (0, 1):
                slices.append(
                    encode_slice_recursive(volume, x_split[x], x_split[x + 1],
                                           y_split[y], y_split[y + 1],
                                           z_split[z], z_split[z + 1]))
    # slice
    return f"s{" ".join(slices)}"


def encode(volume: np.ndarray) -> str:
    """
    Encode a bit volume as an octree and convert it to a string.
    """
    if not isinstance(volume, np.ndarray):
        raise TypeError("Provided volume is not a valid Numpy ndarray")

    shape = volume.shape
    if len(shape) != 3:
        raise ValueError(
            f"Passed volume with invalid dimensions. Expected 3, received {dimensions}."
        )

    resolution = shape[0]
    if shape != (resolution, resolution, resolution):
        raise ValueError(
            f"Dimension mismatch. Expected ({resolution},{resolution},{resolution}), received {shape}"
        )

    depth = np.log2(resolution)
    if int(depth) != depth:
        raise ValueError(
            f"Passed volume with invalid resolution. Expected a power of 2, received {resolution}."
        )

    string = encode_slice_recursive(volume, 0, resolution, 0, resolution, 0,
                                    resolution)
    return f"{resolution} {string}"


def decode_slice_recursive(tokens, idx, volume, x_start, x_end, y_start, y_end,
                           z_start, z_end):
    if idx >= len(tokens):
        raise ValueError("Unexpected end of encoding")

    token = tokens[idx]
    idx = idx + 1

    # leaf, read the next value
    if token == 'L':
        val = int(tokens[idx])
        volume[x_start:x_end, y_start:y_end, z_start:z_end] = val
        return idx + 1

    # split
    if token == 'S':
        x_split = [x_start, (x_start + x_end) // 2, x_end]
        y_split = [y_start, (y_start + y_end) // 2, y_end]
        z_split = [z_start, (z_start + z_end) // 2, z_end]
        for z in (0, 1):
            for y in (0, 1):
                for x in (0, 1):
                    idx = decode_slice_recursive(tokens, idx, volume,
                                                 x_split[x], x_split[x + 1],
                                                 y_split[y], y_split[y + 1],
                                                 z_split[z], z_split[z + 1])
        return idx

    raise ValueError(f"Invalid token '{token}' at position {idx-1}")


def decode(encoding: str) -> np.ndarray:
    """
    Decode a string representing an octree and save it as a bit volume
    """
    if not isinstance(encoding, str):
        raise TypeError("Provided encoding is not a valid string")

    split_encoding = encoding.split(" ", 1)
    if len(split_encoding) != 2:
        raise ValueError(
            "The encoding is not properly formatted. Expected \"[volume resolution] [octree encoding]\""
        )

    resolution, tokens = split_encoding
    try:
        resolution = int(resolution)
    except ValueError:
        raise ValueError(
            f"Passed encoding with invalid resolution. Expected a positive number, received {resolution}."
        )

    if resolution < 1:
        raise ValueError(
            f"Passed encoding with invalid resolution. Expected a positive number, received {resolution}."
        )

    volume = np.zeros((resolution, resolution, resolution), dtype=np.uint8)

    final_idx = decode_slice_recursive(tokens, 0, volume, 0, resolution, 0,
                                       resolution, 0, resolution)
    return volume


data_file = "./samples/sparse.dat"
with open(data_file, 'r', encoding='utf-8') as f:
    encoded = f.readlines()[0]
    volume = decode(encoded)
    print(volume.flatten().tolist())

    # lines = f.readlines()
    # hex_str = lines[0].strip()
    # byte_array = bytes.fromhex(hex_str)
    # bits = np.unpackbits(np.frombuffer(byte_array, dtype=np.uint8),
    #                      bitorder="little")
    # volume = bits.reshape((128, 128, 128))

    # encoded = encode(volume)
    # with open("output.dat", "w", encoding="utf-8") as f:
    #     f.write(encoded)